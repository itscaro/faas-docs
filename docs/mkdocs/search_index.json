{
    "docs": [
        {
            "location": "/",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/faas/README/",
            "text": "OpenFaaS - Functions as a Service\n\n\n \n \n\n\n\n\n\n\nOpenFaaS (Functions as a Service) is a framework for building serverless functions with Docker which has first class support for metrics. Any process can be packaged as a function enabling you to consume a range of web events without repetitive boiler-plate coding.\n\n\n\n\nHighlights\n\n\n\n\nEase of use through UI portal and \none-click\n install\n\n\nWrite functions in any language for Linux or Windows and package in Docker/OCI image format\n\n\nPortable - runs on existing hardware or public/private cloud - \nKubernetes\n and Docker Swarm native\n\n\nCLI\n available with YAML format for templating and defining functions\n\n\nAuto-scales as demand increases\n\n\n\n\nGovernance\n\n\nOpenFaaS is an independent project created by \nAlex Ellis\n which is now being built and shaped by a growing community of contributors. Project website: \nopenfaas.com\n.\n\n\nOverview of OpenFaaS\n\n\n\n\nFunction Watchdog\n\n\n\n\nYou can make any Docker image into a serverless function by adding the \nFunction Watchdog\n (a tiny Golang HTTP server)\n\n\nThe \nFunction Watchdog\n is the entrypoint allowing HTTP requests to be forwarded to the target process via STDIN. The response is sent back to the caller by writing to STDOUT from your application.\n\n\n\n\nAPI Gateway / UI Portal\n\n\n\n\nThe API Gateway provides an external route into your functions and collects Cloud Native metrics through Prometheus.\n\n\nYour API Gateway will scale functions according to demand by altering the service replica count in the Docker Swarm or Kubernetes API.\n\n\nA UI is baked in allowing you to invoke functions in your browser and create new ones as needed.\n\n\n\n\n\n\nThe API Gateway is a RESTful micro-service and you can view the \nSwagger docs here\n.\n\n\n\n\nCLI\n\n\nAny container or process in a Docker container can be a serverless function in FaaS. Using the \nFaaS CLI\n you can deploy your functions or quickly create new functions from templates such as Node.js or Python.\n\n\n\n\nThe CLI is effectively a RESTful client for the API Gateway.\n\n\n\n\nWhen you have OpenFaaS configured you can \nget started with the CLI here\n\n\nFunction examples\n\n\nYou can generate new functions using the FaaS-CLI and built-in templates or use any binary for Windows or Linux in a Docker container.\n\n\n\n\nPython example:\n\n\n\n\nimport requests\n\ndef handle(req):\n        r =  requests.get(req, timeout = 1)\n        print(req +\" => \" + str(r.status_code))\n\n\n\n\nhandler.py\n\n\n\n\nNode.js example:\n\n\n\n\n\"use strict\"\n\nmodule.exports = (callback, context) => {\n    callback(null, {\"message\": \"You said: \" + context})\n}\n\n\n\n\nhandler.js\n\n\nOther \nSample functions\n are available in the Github repository in a range of programming languages.\n\n\nGet started with OpenFaaS\n\n\nTestDrive\n\n\nDocker Swarm\n\n\nThe deployment guide for Docker Swarm contains a simple one-line command to get you up and running in around 60 seconds. It also includes a set of \nsample functions\n which you can use with the TestDrive instructions below.\n\n\nDeployment guide for Docker Swarm\n\n\nKubernetes\n\n\nOpenFaaS is Kubernetes-native - you can follow the \ndeployment guide here\n.\n\n\nDocker Playground\n\n\nYou can quickly start OpenFaaS on Docker Swarm online using the community-run Docker playground: play-with-docker.com (PWD) by clicking the button below:\n\n\n\n\nBegin the TestDrive\n\n\n\n\nBegin the TestDrive with Docker Swarm\n\n\n\n\nHere is a screenshot of the API gateway portal - designed for ease of use.\n\n\n\n\nFind out more about OpenFaaS\n\n\nSkillsMatter video presentation\n\n\nGreat overview of OpenFaaS features, users and roadmap\n\n\n\n\nHD Video\n\n\n\n\nOpenFaaS presents to CNCF Serverless workgroup\n\n\n\n\nVideo and blog post\n\n\n\n\nClosing Keynote at Dockercon 2017\n\n\nFunctions as a Service or FaaS was a winner in the Cool Hacks contest for Dockercon 2017.\n\n\n\n\nWatch my FaaS keynote at Dockercon 2017\n\n\n\n\nIf you'd like to find the functions I used in the demos head over to the \nfaas-dockercon\n repository.\n\n\nBackground story\n\n\nThis is my original blog post on FaaS from January: \nFunctions as a Service blog post\n\n\nCommunity\n\n\nHave you written a blog about OpenFaaS? Send a Pull Request to the community page below.\n\n\n\n\nRead blogs/articles and find events about OpenFaaS\n\n\n\n\nIf you'd like to join OpenFaaS community Slack channel to chat with contributors or get some help - then send a Tweet to \n@alexellisuk\n or email alex@openfaas.com.\n\n\nRoadmap and contributing\n\n\nOpenFaaS is written in Golang and is MIT licensed - contributions are welcomed whether that means providing feedback, testing existing and new feature or hacking on the source.\n\n\nTo get started you can read the \nroadmap\n and \ncontribution guide\n or:\n\n\n\n\nBrowse FaaS issues on Github\n.\n\n\nBrowse FaaS-CLI issues on Github\n.\n\n\n\n\nHighlights:\n\n\n\n\nNew: Kubernetes support via \nFaaS-netes\n plugin\n\n\nNew: FaaS CLI and easy install via \ncurl\n and \nbrew\n\n\nNew: Windows function support\n\n\nNew: Asynchronous/long-running OpenFaaS functions via \nNATS Streaming\n - \nFollow this guide\n\n\n\n\nHow do I become a contributor?\n\n\nAnyone is invited to contribute to the project in-line with the \ncontribution guide\n - you can also read the guide for ideas on how to get involved. We invite new contributors to join our Slack community. We would also ask you to propose any changes or contributions ahead of time, especially when there is no issue or proposal alredy tracking it.\n\n\nOther\n\n\nExample of a Grafana dashboard linked to OpenFaaS showing auto-scaling live in action:\n\n\n\n\nSample dashboard JSON file available \nhere",
            "title": "Gateway"
        },
        {
            "location": "/faas/README/#openfaas-functions-as-a-service",
            "text": "OpenFaaS (Functions as a Service) is a framework for building serverless functions with Docker which has first class support for metrics. Any process can be packaged as a function enabling you to consume a range of web events without repetitive boiler-plate coding.   Highlights   Ease of use through UI portal and  one-click  install  Write functions in any language for Linux or Windows and package in Docker/OCI image format  Portable - runs on existing hardware or public/private cloud -  Kubernetes  and Docker Swarm native  CLI  available with YAML format for templating and defining functions  Auto-scales as demand increases",
            "title": "OpenFaaS - Functions as a Service"
        },
        {
            "location": "/faas/README/#governance",
            "text": "OpenFaaS is an independent project created by  Alex Ellis  which is now being built and shaped by a growing community of contributors. Project website:  openfaas.com .",
            "title": "Governance"
        },
        {
            "location": "/faas/README/#overview-of-openfaas",
            "text": "",
            "title": "Overview of OpenFaaS"
        },
        {
            "location": "/faas/README/#function-watchdog",
            "text": "You can make any Docker image into a serverless function by adding the  Function Watchdog  (a tiny Golang HTTP server)  The  Function Watchdog  is the entrypoint allowing HTTP requests to be forwarded to the target process via STDIN. The response is sent back to the caller by writing to STDOUT from your application.",
            "title": "Function Watchdog"
        },
        {
            "location": "/faas/README/#api-gateway-ui-portal",
            "text": "The API Gateway provides an external route into your functions and collects Cloud Native metrics through Prometheus.  Your API Gateway will scale functions according to demand by altering the service replica count in the Docker Swarm or Kubernetes API.  A UI is baked in allowing you to invoke functions in your browser and create new ones as needed.    The API Gateway is a RESTful micro-service and you can view the  Swagger docs here .",
            "title": "API Gateway / UI Portal"
        },
        {
            "location": "/faas/README/#cli",
            "text": "Any container or process in a Docker container can be a serverless function in FaaS. Using the  FaaS CLI  you can deploy your functions or quickly create new functions from templates such as Node.js or Python.   The CLI is effectively a RESTful client for the API Gateway.   When you have OpenFaaS configured you can  get started with the CLI here",
            "title": "CLI"
        },
        {
            "location": "/faas/README/#function-examples",
            "text": "You can generate new functions using the FaaS-CLI and built-in templates or use any binary for Windows or Linux in a Docker container.   Python example:   import requests\n\ndef handle(req):\n        r =  requests.get(req, timeout = 1)\n        print(req +\" => \" + str(r.status_code))  handler.py   Node.js example:   \"use strict\"\n\nmodule.exports = (callback, context) => {\n    callback(null, {\"message\": \"You said: \" + context})\n}  handler.js  Other  Sample functions  are available in the Github repository in a range of programming languages.",
            "title": "Function examples"
        },
        {
            "location": "/faas/README/#get-started-with-openfaas",
            "text": "",
            "title": "Get started with OpenFaaS"
        },
        {
            "location": "/faas/README/#testdrive",
            "text": "Docker Swarm  The deployment guide for Docker Swarm contains a simple one-line command to get you up and running in around 60 seconds. It also includes a set of  sample functions  which you can use with the TestDrive instructions below.  Deployment guide for Docker Swarm  Kubernetes  OpenFaaS is Kubernetes-native - you can follow the  deployment guide here .  Docker Playground  You can quickly start OpenFaaS on Docker Swarm online using the community-run Docker playground: play-with-docker.com (PWD) by clicking the button below:",
            "title": "TestDrive"
        },
        {
            "location": "/faas/README/#begin-the-testdrive",
            "text": "Begin the TestDrive with Docker Swarm   Here is a screenshot of the API gateway portal - designed for ease of use.",
            "title": "Begin the TestDrive"
        },
        {
            "location": "/faas/README/#find-out-more-about-openfaas",
            "text": "",
            "title": "Find out more about OpenFaaS"
        },
        {
            "location": "/faas/README/#skillsmatter-video-presentation",
            "text": "Great overview of OpenFaaS features, users and roadmap   HD Video",
            "title": "SkillsMatter video presentation"
        },
        {
            "location": "/faas/README/#openfaas-presents-to-cncf-serverless-workgroup",
            "text": "Video and blog post",
            "title": "OpenFaaS presents to CNCF Serverless workgroup"
        },
        {
            "location": "/faas/README/#closing-keynote-at-dockercon-2017",
            "text": "Functions as a Service or FaaS was a winner in the Cool Hacks contest for Dockercon 2017.   Watch my FaaS keynote at Dockercon 2017   If you'd like to find the functions I used in the demos head over to the  faas-dockercon  repository.  Background story  This is my original blog post on FaaS from January:  Functions as a Service blog post",
            "title": "Closing Keynote at Dockercon 2017"
        },
        {
            "location": "/faas/README/#community",
            "text": "Have you written a blog about OpenFaaS? Send a Pull Request to the community page below.   Read blogs/articles and find events about OpenFaaS   If you'd like to join OpenFaaS community Slack channel to chat with contributors or get some help - then send a Tweet to  @alexellisuk  or email alex@openfaas.com.",
            "title": "Community"
        },
        {
            "location": "/faas/README/#roadmap-and-contributing",
            "text": "OpenFaaS is written in Golang and is MIT licensed - contributions are welcomed whether that means providing feedback, testing existing and new feature or hacking on the source.  To get started you can read the  roadmap  and  contribution guide  or:   Browse FaaS issues on Github .  Browse FaaS-CLI issues on Github .   Highlights:   New: Kubernetes support via  FaaS-netes  plugin  New: FaaS CLI and easy install via  curl  and  brew  New: Windows function support  New: Asynchronous/long-running OpenFaaS functions via  NATS Streaming  -  Follow this guide",
            "title": "Roadmap and contributing"
        },
        {
            "location": "/faas/README/#how-do-i-become-a-contributor",
            "text": "Anyone is invited to contribute to the project in-line with the  contribution guide  - you can also read the guide for ideas on how to get involved. We invite new contributors to join our Slack community. We would also ask you to propose any changes or contributions ahead of time, especially when there is no issue or proposal alredy tracking it.",
            "title": "How do I become a contributor?"
        },
        {
            "location": "/faas/README/#other",
            "text": "Example of a Grafana dashboard linked to OpenFaaS showing auto-scaling live in action:   Sample dashboard JSON file available  here",
            "title": "Other"
        },
        {
            "location": "/faas/DEV/",
            "text": "Develop your own function\n\n\nTestDrive\n\n\nBefore you start development, you may want to take FaaS for a test drive which sets up a stack of sample functions from docker-compose.yml. You can then build your own functions and add them to the stack.\n\n\n\n\nYou can test-drive FaaS with a set of sample functions as defined in docker-compose.yml on play-with-docker.com for free, or on your own laptop.\n\n\n\n\n\n\nBegin the TestDrive instructions\n\n\n\n\nWorking on the API Gateway or Watchdog\n\n\nTo work on either of the FaaS Golang components checkout the \"./build.sh\" scripts and acompanying Dockerfiles.\n\n\n\n\nRoadmap and Contributing\n\n\n\n\nCreating a function\n\n\nFunctions run as Docker containers with the Watchdog component embedded to handle communication with the API Gateway.\n\n\nYou can find the \nreference documentation for the Watchdog here\n.\n\n\nMarkdown Parser\n\n\nThis is the basis of a function which generates HTML from MarkDown:\n\n\nFROM golang:1.7.5\nRUN mkdir -p /go/src/app\nCOPY handler.go /go/src/app\nWORKDIR /go/src/app\nRUN go get github.com/microcosm-cc/bluemonday && \\\n    go get github.com/russross/blackfriday\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n\nADD https://github.com/openfaas/faas/releases/download/v0.3-alpha/fwatchdog /usr/bin\nRUN chmod +x /usr/bin/fwatchdog\n\nENV fprocess=\"/go/src/app/app\"\n\nCMD [\"/usr/bin/fwatchdog\"]\n\n\n\n\nThe base Docker container is not important, you just need to add the watchdog component and then set the fprocess to execute your binary at runtime.\n\n\nUpdate the Docker stack with this:\n\n\n    markdown:\n        image: alexellis2/faas-markdownrender:latest\n        labels:\n            function: \"true\"\n        depends_on:\n            - gateway\n        networks:\n            - functions\n\n\n\n\nWord counter with busybox\n\n\nFROM alpine:latest\n\nADD https://github.com/openfaas/faas/releases/download/v0.3-alpha/fwatchdog /usr/bin\nRUN chmod +x /usr/bin/fwatchdog\n\nENV fprocess=\"wc\"\nCMD [\"fwatchdog\"]\n\n\n\n\nUpdate your Docker stack with this definition:\n\n\n    wordcount:\n        image: alexellis2/faas-alpinefunction:latest\n        labels:\n            function: \"true\"\n        depends_on:\n            - gateway\n        networks:\n            - functions\n        environment:\n            fprocess:   \"wc\"\n\n\n\n\nTesting your function\n\n\nYou can test your function through a webbrowser against the UI portal on port 8080.\n\n\nhttp://localhost:8080/\n\n\nYou can also invoke a function by name with curl:\n\n\ncurl --data-binary @README.md http://localhost:8080/function/func_wordcount",
            "title": "Dev"
        },
        {
            "location": "/faas/DEV/#develop-your-own-function",
            "text": "",
            "title": "Develop your own function"
        },
        {
            "location": "/faas/DEV/#testdrive",
            "text": "Before you start development, you may want to take FaaS for a test drive which sets up a stack of sample functions from docker-compose.yml. You can then build your own functions and add them to the stack.   You can test-drive FaaS with a set of sample functions as defined in docker-compose.yml on play-with-docker.com for free, or on your own laptop.    Begin the TestDrive instructions",
            "title": "TestDrive"
        },
        {
            "location": "/faas/DEV/#working-on-the-api-gateway-or-watchdog",
            "text": "To work on either of the FaaS Golang components checkout the \"./build.sh\" scripts and acompanying Dockerfiles.   Roadmap and Contributing",
            "title": "Working on the API Gateway or Watchdog"
        },
        {
            "location": "/faas/DEV/#creating-a-function",
            "text": "Functions run as Docker containers with the Watchdog component embedded to handle communication with the API Gateway.  You can find the  reference documentation for the Watchdog here .  Markdown Parser  This is the basis of a function which generates HTML from MarkDown:  FROM golang:1.7.5\nRUN mkdir -p /go/src/app\nCOPY handler.go /go/src/app\nWORKDIR /go/src/app\nRUN go get github.com/microcosm-cc/bluemonday && \\\n    go get github.com/russross/blackfriday\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n\nADD https://github.com/openfaas/faas/releases/download/v0.3-alpha/fwatchdog /usr/bin\nRUN chmod +x /usr/bin/fwatchdog\n\nENV fprocess=\"/go/src/app/app\"\n\nCMD [\"/usr/bin/fwatchdog\"]  The base Docker container is not important, you just need to add the watchdog component and then set the fprocess to execute your binary at runtime.  Update the Docker stack with this:      markdown:\n        image: alexellis2/faas-markdownrender:latest\n        labels:\n            function: \"true\"\n        depends_on:\n            - gateway\n        networks:\n            - functions  Word counter with busybox  FROM alpine:latest\n\nADD https://github.com/openfaas/faas/releases/download/v0.3-alpha/fwatchdog /usr/bin\nRUN chmod +x /usr/bin/fwatchdog\n\nENV fprocess=\"wc\"\nCMD [\"fwatchdog\"]  Update your Docker stack with this definition:      wordcount:\n        image: alexellis2/faas-alpinefunction:latest\n        labels:\n            function: \"true\"\n        depends_on:\n            - gateway\n        networks:\n            - functions\n        environment:\n            fprocess:   \"wc\"",
            "title": "Creating a function"
        },
        {
            "location": "/faas/DEV/#testing-your-function",
            "text": "You can test your function through a webbrowser against the UI portal on port 8080.  http://localhost:8080/  You can also invoke a function by name with curl:  curl --data-binary @README.md http://localhost:8080/function/func_wordcount",
            "title": "Testing your function"
        },
        {
            "location": "/faas/ROADMAP/",
            "text": "Roadmap\n\n\n1. Current features\n\n\nFor an overview of features in August 2017 read the following post:\n\n\n\n\nIntroducing Functions as a Service (FaaS)\n\n\n\n\nGitHub repos:\n\n\n\n\nhttps://github.com/openfaas/faas\n\n\nhttps://github.com/openfaas/faas-netes\n\n\nhttps://github.com/openfaas/faas-cli\n\n\nhttps://github.com/openfaas/nats-queue-worker\n\n\n\n\nThe API Gateway\n\n\nThis container acts in a similar way to the API Gateway on AWS. Requests can be made to this endpoint with a JSON body.\n\n\nSome of the more recent Completed Features:\n\n\n\n\nUI for viewing and testing functions deployed through stack\n\n\nAuto-scaling of replicas as load increases\n\n\nBacking off of replicas as load reduces\n\n\nUnique URL routes for serverless functions\n\n\nInstrumentation via Prometheus metrics at GET /metrics\n\n\nBundled Prometheus stack with AlertManager\n\n\nUI enhancements to create new function through a form\n\n\nRaspberry Pi (armhf/armv6) support (currently available)\n\n\nDocumentation for current API in Swagger format\n\n\nDocumentation about \nAlexa sample function\n\n\nNative CLI for templating/building and deploying functions\n\n\nWindows support for watchdog back-end - so that Windows executables can be used in a multi-OS swarm\n\n\nEnforcing function execution time in seconds.\n\n\nPython, Node.js, Ruby and CSharp code templates for the CLI\n\n\nDelete function in CLI\n\n\nDeveloper guide for CSharp\n\n\nDeveloper guide for Python\n\n\nKubernetes support\n\n\nAsynchronous / long-running tasks via NATS Streaming\n\n\nCLI - invoke / list functions / query function info\n\n\nOS constraints in the deploy function API\n\n\n\n\nIncoming requests and routing\n\n\nThere are three options for routing:\n\n\n\n\nFunctions created on the overlay network can be invoked by: http://localhost:8080/function/{servicename}\n\n\nAutomatic routing is also enabled through the \n/\n endpoint via a \nX-Function\n header which matches a service name (function) directly.\n\n\n\n\nThe watchdog\n\n\nThis binary fwatchdog acts as a watchdog for your function. Features:\n\n\n\n\nStatic binary in Go\n\n\nListens to HTTP requests over swarm overlay network\n\n\nSpawns process set in \nfprocess\n ENV variable for each HTTP connection\n\n\nOnly lets processes run for set duration i.e. 500ms, 2s, 3s.\n\n\nLanguage/binding independent - can invoke any UNIX process, including built-ins such as \nwc\n or \ncat\n\n\nCan also run Windows native binaries\n\n\n\n\n2. Future items\n\n\nMost items are detailed \nvia Github issues\n.\n\n\nNative support is available for Docker Swarm and Kubernetes using primitive API objects in each orchestration platform.\n\n\nMust have\n\n\n\n\nDeveloper Cloud guides:\n\n\nfor Digital Ocean\n\n\nfor Packet\n\n\n\n\nfor AWS\n\n\n\n\n\n\nRe-branding to OpenFaaS (in-progress)\n\n\n\n\nNew logo - graphic icon and text (in-progress)\n\n\n\n\nWebsite / landing page (in progress)\n\n\n\n\n\n\nDeveloper guide for your first Node.js function\n\n\n\n\nDeveloper guide to using functions together - via pipes on client, or a \"director\" function on server\n\n\n\n\nShould have\n\n\n\n\nhelm chart\n\n\nCertifier for third-party integrations (via e2e tests) \n\n\nAfterBurn - fork once, use many which removes almost all runtime latency - (in progress)\n\n\nKafka queue worker implementation (async currently available by NATS Streaming)\n\n\nNon-root Docker templates for the CLI (in progress)\n\n\nCommunity templates for the FaaS-CLI (in progress)\n\n\nOur own \"timer\" (aka cron) for invoking functions on a regular basis - or a guide for setting this up via Jenkins or CRON\n\n\nIntegration with a reverse proxy - such as Traefik or Kong\n\n\nI.e. for TLS termination\n\n\nBasic auth for /system endpoints (probably via reverse proxy)\n\n\nAARCH64 (64-bit ARM) port (dependent on Docker release schedule)\n\n\nHealthchecks for functions deployed on Kubernetes\n\n\n\n\nCould have\n\n\n\n\nMulti-tenancy (in-progress for Kubernetes and Docker Swarm)\n\n\nProgress animation for building Docker images via CLI\n\n\nBuilt-in Docker registry with default configuration\n\n\nDocker image builder (remote service)\n\n\nFunction store - list of useful predefined functions\n\n\nSupporting request parameters via route\n\n\nConfigurable memory limits via \"new function\" pop-up (already supported by Docker compose stack)\n\n\nScale to zero 0/0 replicas\n\n\nGuide/proxy for Flask in a function\n\n\n\n\nNice to have\n\n\n\n\nGuide for basic authentication over HTTPs (set up externally through NGinx etc)\n\n\nCRIU - (Checkpoint/Restore In Userspace) for starting serverless tasks with a high start-up cost/latency.\n\n\nDeeper tests coverage and integration tests\n\n\nServerless Inc framework support - as a \"provider\"\n\n\n\n\nOn-going integrations in addition to Swarm and K8s:\n\n\n\n\nECS - via Huawei\n\n\nNomad via Hashicorp\n\n\nHyper.sh via Hyper\n\n\nCattle / Rancher by community\n\n\n\n\nInternal research is also being done for the ACI / K8s-connector.\n\n\nContributing\n\n\nPlease see \nCONTRIBUTING.md\n.",
            "title": "Roadmap"
        },
        {
            "location": "/faas/ROADMAP/#roadmap",
            "text": "",
            "title": "Roadmap"
        },
        {
            "location": "/faas/ROADMAP/#1-current-features",
            "text": "For an overview of features in August 2017 read the following post:   Introducing Functions as a Service (FaaS)",
            "title": "1. Current features"
        },
        {
            "location": "/faas/ROADMAP/#github-repos",
            "text": "https://github.com/openfaas/faas  https://github.com/openfaas/faas-netes  https://github.com/openfaas/faas-cli  https://github.com/openfaas/nats-queue-worker",
            "title": "GitHub repos:"
        },
        {
            "location": "/faas/ROADMAP/#the-api-gateway",
            "text": "This container acts in a similar way to the API Gateway on AWS. Requests can be made to this endpoint with a JSON body.  Some of the more recent Completed Features:   UI for viewing and testing functions deployed through stack  Auto-scaling of replicas as load increases  Backing off of replicas as load reduces  Unique URL routes for serverless functions  Instrumentation via Prometheus metrics at GET /metrics  Bundled Prometheus stack with AlertManager  UI enhancements to create new function through a form  Raspberry Pi (armhf/armv6) support (currently available)  Documentation for current API in Swagger format  Documentation about  Alexa sample function  Native CLI for templating/building and deploying functions  Windows support for watchdog back-end - so that Windows executables can be used in a multi-OS swarm  Enforcing function execution time in seconds.  Python, Node.js, Ruby and CSharp code templates for the CLI  Delete function in CLI  Developer guide for CSharp  Developer guide for Python  Kubernetes support  Asynchronous / long-running tasks via NATS Streaming  CLI - invoke / list functions / query function info  OS constraints in the deploy function API   Incoming requests and routing  There are three options for routing:   Functions created on the overlay network can be invoked by: http://localhost:8080/function/{servicename}  Automatic routing is also enabled through the  /  endpoint via a  X-Function  header which matches a service name (function) directly.",
            "title": "The API Gateway"
        },
        {
            "location": "/faas/ROADMAP/#the-watchdog",
            "text": "This binary fwatchdog acts as a watchdog for your function. Features:   Static binary in Go  Listens to HTTP requests over swarm overlay network  Spawns process set in  fprocess  ENV variable for each HTTP connection  Only lets processes run for set duration i.e. 500ms, 2s, 3s.  Language/binding independent - can invoke any UNIX process, including built-ins such as  wc  or  cat  Can also run Windows native binaries",
            "title": "The watchdog"
        },
        {
            "location": "/faas/ROADMAP/#2-future-items",
            "text": "Most items are detailed  via Github issues .  Native support is available for Docker Swarm and Kubernetes using primitive API objects in each orchestration platform.  Must have   Developer Cloud guides:  for Digital Ocean  for Packet   for AWS    Re-branding to OpenFaaS (in-progress)   New logo - graphic icon and text (in-progress)   Website / landing page (in progress)    Developer guide for your first Node.js function   Developer guide to using functions together - via pipes on client, or a \"director\" function on server   Should have   helm chart  Certifier for third-party integrations (via e2e tests)   AfterBurn - fork once, use many which removes almost all runtime latency - (in progress)  Kafka queue worker implementation (async currently available by NATS Streaming)  Non-root Docker templates for the CLI (in progress)  Community templates for the FaaS-CLI (in progress)  Our own \"timer\" (aka cron) for invoking functions on a regular basis - or a guide for setting this up via Jenkins or CRON  Integration with a reverse proxy - such as Traefik or Kong  I.e. for TLS termination  Basic auth for /system endpoints (probably via reverse proxy)  AARCH64 (64-bit ARM) port (dependent on Docker release schedule)  Healthchecks for functions deployed on Kubernetes   Could have   Multi-tenancy (in-progress for Kubernetes and Docker Swarm)  Progress animation for building Docker images via CLI  Built-in Docker registry with default configuration  Docker image builder (remote service)  Function store - list of useful predefined functions  Supporting request parameters via route  Configurable memory limits via \"new function\" pop-up (already supported by Docker compose stack)  Scale to zero 0/0 replicas  Guide/proxy for Flask in a function   Nice to have   Guide for basic authentication over HTTPs (set up externally through NGinx etc)  CRIU - (Checkpoint/Restore In Userspace) for starting serverless tasks with a high start-up cost/latency.  Deeper tests coverage and integration tests  Serverless Inc framework support - as a \"provider\"   On-going integrations in addition to Swarm and K8s:   ECS - via Huawei  Nomad via Hashicorp  Hyper.sh via Hyper  Cattle / Rancher by community   Internal research is also being done for the ACI / K8s-connector.",
            "title": "2. Future items"
        },
        {
            "location": "/faas/ROADMAP/#contributing",
            "text": "Please see  CONTRIBUTING.md .",
            "title": "Contributing"
        },
        {
            "location": "/faas/CONTRIBUTING/",
            "text": "Contributing\n\n\nGuidelines\n\n\nGuidelines for contributing.\n\n\nHow can I get involved?\n\n\nFirst of all, we'd love to welcome you into the our Slack community where we chat, exchange ideas and ask questions. See below for how to join.\n\n\nWe have a number of areas where we can accept contributions:\n\n\n\n\nWrite Golang code for the CLI, Gateway or other providers\n\n\nWrite for our front-end UI\n\n\nReview pull requests\n\n\nManage, triage and research Issues and Pull Requests\n\n\nHelp our growing community feel at home\n\n\nCreate docs, guides and blogging\n\n\nSpeak at meet-ups, conferences or by helping folks with OpenFaaS on Slack\n\n\n\n\nI've found a typo\n\n\n\n\nA Pull Request is not necessary. Raise an \nIssue\n and we'll fix it as soon as we can. \n\n\n\n\nI have a [great] idea\n\n\nThe OpenFaaS maintainers would like to make OpenFaaS the best it can be and welcome new contributions that align with the project's goals. Our time is limited so we'd like to make sure we agree on the proposed work before you spend time doing it. Saying \"no\" is hard which is why we'd rather say \"yes\" ahead of time.\n\n\nWhat makes a good proposal?\n\n\n\n\nBrief summary including motivation/context\n\n\nAny design changes\n\n\nPros + Cons\n\n\nEffort required\n\n\nMock-up screenshots or examples of how the CLI would work\n\n\n\n\nPaperwork for Pull Requests\n\n\nPlease read this whole guide and make sure you agree to our DCO agreement (included below):\n\n\n\n\nSign-off your commits \n\n\nComplete the whole template for issues and pull requests\n\n\nReference addressed issues\n in the PR description & commit messages - use 'Fixes #IssueNo' \n\n\nAlways give instructions for testing\n\n\nProvide us CLI commands and output or screenshots where you can \n\n\n\n\nUnit testing with Golang\n\n\nPlease follow style guide on \nthis blog post\n from \nThe Go Programming Language\n\n\nI have a question, a suggestion or need help\n\n\nPlease raise an Issue or email alex@openfaas.com for an invitation to our Slack community.\n\n\nI need to add a dependency\n\n\nWe are using the \nvndr\n tool across all projects. Get \nstarted here\n.\n\n\nHow do I become a maintainer?\n\n\nMaintainers are well-known contributors who help with:\n\n Fixing, testing and triaging issues\n\n Joining contributor meetings and supporting new contributors\n\n Testing and reviewing pull requests\n\n Offering other project support and strategical advice\n\n\nVarying levels of write access are made available via our project bot \nDerek\n to help regular contributors transition to maintainers.\n\n\nGovernance\n\n\nOpenFaaS is an independent project created by Alex Ellis which is now being built by a growing community of contributors.\n\n\nCommunity\n\n\nThis project is written in Golang but many of the community contributions so far have been through blogging, speaking engagements, helping to test and drive the backlog of FaaS. If you'd like to help in any way then that would be more than welcome whatever your level of experience.\n\n\nCommunity file\n\n\nThe \ncommunity.md\n file highlights blogs, talks and code repos with example FaaS functions and usages. Please send a Pull Request if you are doing something cool with FaaS.\n\n\nRoadmap\n\n\nCheckout the \nroadmap\n and \nopen issues\n.\n\n\nSlack\n\n\nThere is an Slack community which you are welcome to join to discuss FaaS, IoT and Raspberry Pi projects. Ping \nAlex Ellis\n with your email address so that an invite can be sent out.\n\n\nEmail: alex@openfaas.com - please send in a one-liner about yourself so we can give you a warm welcome and help you get started.\n\n\nLicense\n\n\nThis project is licensed under the MIT License.\n\n\nSign your work\n\n\n\n\nNote: all of the commits in your PR/Patch must be signed-off.\n\n\n\n\nThe sign-off is a simple line at the end of the explanation for a patch. Your\nsignature certifies that you wrote the patch or otherwise have the right to pass\nit on as an open-source patch. The rules are pretty simple: if you can certify\nthe below (from \ndevelopercertificate.org\n):\n\n\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n\n\n\n\nThen you just add a line to every git commit message:\n\n\nSigned-off-by: Joe Smith <joe.smith@email.com>\n\n\n\nUse your real name (sorry, no pseudonyms or anonymous contributions.)\n\n\nIf you set your \nuser.name\n and \nuser.email\n git configs, you can sign your\ncommit automatically with \ngit commit -s\n.\n\n\n\n\nPlease sign your commits with \ngit commit -s\n so that commits are traceable.",
            "title": "Contributing"
        },
        {
            "location": "/faas/CONTRIBUTING/#contributing",
            "text": "",
            "title": "Contributing"
        },
        {
            "location": "/faas/CONTRIBUTING/#guidelines",
            "text": "Guidelines for contributing.  How can I get involved?  First of all, we'd love to welcome you into the our Slack community where we chat, exchange ideas and ask questions. See below for how to join.  We have a number of areas where we can accept contributions:   Write Golang code for the CLI, Gateway or other providers  Write for our front-end UI  Review pull requests  Manage, triage and research Issues and Pull Requests  Help our growing community feel at home  Create docs, guides and blogging  Speak at meet-ups, conferences or by helping folks with OpenFaaS on Slack   I've found a typo   A Pull Request is not necessary. Raise an  Issue  and we'll fix it as soon as we can.    I have a [great] idea  The OpenFaaS maintainers would like to make OpenFaaS the best it can be and welcome new contributions that align with the project's goals. Our time is limited so we'd like to make sure we agree on the proposed work before you spend time doing it. Saying \"no\" is hard which is why we'd rather say \"yes\" ahead of time.  What makes a good proposal?   Brief summary including motivation/context  Any design changes  Pros + Cons  Effort required  Mock-up screenshots or examples of how the CLI would work   Paperwork for Pull Requests  Please read this whole guide and make sure you agree to our DCO agreement (included below):   Sign-off your commits   Complete the whole template for issues and pull requests  Reference addressed issues  in the PR description & commit messages - use 'Fixes #IssueNo'   Always give instructions for testing  Provide us CLI commands and output or screenshots where you can    Unit testing with Golang  Please follow style guide on  this blog post  from  The Go Programming Language  I have a question, a suggestion or need help  Please raise an Issue or email alex@openfaas.com for an invitation to our Slack community.  I need to add a dependency  We are using the  vndr  tool across all projects. Get  started here .  How do I become a maintainer?  Maintainers are well-known contributors who help with:  Fixing, testing and triaging issues  Joining contributor meetings and supporting new contributors  Testing and reviewing pull requests  Offering other project support and strategical advice  Varying levels of write access are made available via our project bot  Derek  to help regular contributors transition to maintainers.  Governance  OpenFaaS is an independent project created by Alex Ellis which is now being built by a growing community of contributors.",
            "title": "Guidelines"
        },
        {
            "location": "/faas/CONTRIBUTING/#community",
            "text": "This project is written in Golang but many of the community contributions so far have been through blogging, speaking engagements, helping to test and drive the backlog of FaaS. If you'd like to help in any way then that would be more than welcome whatever your level of experience.",
            "title": "Community"
        },
        {
            "location": "/faas/CONTRIBUTING/#community-file",
            "text": "The  community.md  file highlights blogs, talks and code repos with example FaaS functions and usages. Please send a Pull Request if you are doing something cool with FaaS.",
            "title": "Community file"
        },
        {
            "location": "/faas/CONTRIBUTING/#roadmap",
            "text": "Checkout the  roadmap  and  open issues .",
            "title": "Roadmap"
        },
        {
            "location": "/faas/CONTRIBUTING/#slack",
            "text": "There is an Slack community which you are welcome to join to discuss FaaS, IoT and Raspberry Pi projects. Ping  Alex Ellis  with your email address so that an invite can be sent out.  Email: alex@openfaas.com - please send in a one-liner about yourself so we can give you a warm welcome and help you get started.",
            "title": "Slack"
        },
        {
            "location": "/faas/CONTRIBUTING/#license",
            "text": "This project is licensed under the MIT License.",
            "title": "License"
        },
        {
            "location": "/faas/CONTRIBUTING/#sign-your-work",
            "text": "Note: all of the commits in your PR/Patch must be signed-off.   The sign-off is a simple line at the end of the explanation for a patch. Your\nsignature certifies that you wrote the patch or otherwise have the right to pass\nit on as an open-source patch. The rules are pretty simple: if you can certify\nthe below (from  developercertificate.org ):  Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.  Then you just add a line to every git commit message:  Signed-off-by: Joe Smith <joe.smith@email.com>  Use your real name (sorry, no pseudonyms or anonymous contributions.)  If you set your  user.name  and  user.email  git configs, you can sign your\ncommit automatically with  git commit -s .   Please sign your commits with  git commit -s  so that commits are traceable.",
            "title": "Sign your work"
        },
        {
            "location": "/faas-cli/README/",
            "text": "faas-cli\n\n\n \n\n\n\n\nThis is a CLI for use with \nOpenFaaS\n - a serverless functions framework for Docker & Kubernetes.\n\n\n\n\nBefore using this tool please setup OpenFaaS by following instructions over on the main repo.\n\n\n\n\nThe CLI can be used to build and deploy functions to \nOpenFaaS\n. You can build OpenFaaS functions from a set of supported language templates (such as Node.js, Python, CSharp and Ruby). That means you just write a handler file such as (handler.py/handler.js) and the CLI does the rest to create a Docker image.\n\n\nDemo: \nASCII cinema\n\n\nTL;DR\n\n\nBlog: Coffee with the FaaS-CLI\n\n\nIntall the CLI\n\n\nThe easiest way to install the faas-cli is through a curl script or \nbrew\n:\n\n\n$ curl -sSL https://cli.openfaas.com | sudo sh\n\n\n\n\nor\n\n\n$ brew install faas-cli\n\n\n\n\n\n\nThe contributing guide has instructions for building from source\n\n\n\n\nRun the CLI\n\n\nThe main commands supported by the CLI are:\n\n\n\n\nfaas-cli new\n - creates a new function via a template in the current directory\n\n\nfaas-cli build\n - builds Docker images from the supported language types\n\n\nfaas-cli push\n - pushes Docker images into a registry\n\n\nfaas-cli deploy\n - deploys the functions into a local or remote OpenFaaS gateway\n\n\nfaas-cli remove\n - removes the functions from a local or remote OpenFaaS gateway\n\n\nfaas-cli invoke\n - invokes the functions and reads from STDIN for the body of the request\n\n\n\n\nHelp for all of the commands supported by the CLI can be found by running:\n\n\n\n\nfaas-cli help\n or \nfaas-cli [command] --help\n\n\n\n\nYou can chose between using a \nprogramming language template\n where you only need to provide a handler file, or a Docker that you can build yourself.\n\n\nTemplates\n\n\nCommand: \nfaas-cli new FUNCTION_NAME --lang python/node/ruby/Dockerfile/etc\n\n\nIn your YAML you can also specify \nlang: node/python/csharp/ruby\n\n\n\n\nSupports common languages\n\n\nQuick and easy - just write one file\n\n\n\n\nSpecify depenencies on Gemfile / requirements.txt or package.json etc\n\n\n\n\n\n\nCustomise the provided templates\n\n\n\n\n\n\nPerhaps you need to have \ngcc\n or another dependency\n in your Python template? That's not a problem.\n\n\nYou can customise the Dockerfile or code for any of the templates. Just create a new directory and copy in the templates folder from this repository. The templates in your current working directory are always used for builds.\n\n\nSee also: \nfaas-cli new --help\n\n\nDocker image\n\n\nSpecify \nlang: Dockerfile\n if you want the faas-cli to execute a build or \nskip_build: true\n for pre-supplied images.\n\n\n\n\nUltimate versatility and control\n\n\nPackage anything\n\n\nIf you are using a stack file add the \nskip_build: true\n attribute\n\n\nUse one of the \nsamples as a basis\n\n\n\n\nUse a YAML stack file\n\n\nA YAML stack file groups functions together and also saves on typing.\n\n\nYou can define individual functions or a set of of them within a YAML file. This makes the CLI easier to use and means you can use this file to deploy to your OpenFaaS instance.\n\n\nHere is an example file using the \nsamples.yml\n file included in the repository.\n\n\nprovider:\n  name: faas\n  gateway: http://localhost:8080\n\nfunctions:\n  url-ping:\n    lang: python\n    handler: ./sample/url-ping\n    image: alexellis2/faas-urlping\n\n\n\n\nThis url-ping function is defined in the sample/url-ping folder makes use of Python. All we had to do was to write a \nhandler.py\n file and then to list off any Python modules in \nrequirements.txt\n.\n\n\n\n\nBuild the files in the .yml file:\n\n\n\n\n$ faas-cli build -f ./samples.yml\n\n\n\n\n\n\n-f\n specifies the file or URL to download your YAML file from. The long version of the \n-f\n flag is: \n--yaml\n.\n\n\n\n\nYou can also download over HTTP/s:\n\n\n$ faas-cli build -f https://raw.githubusercontent.com/openfaas/faas-cli/master/samples.yml\n\n\n\n\nDocker along with a Python template will be used to build an image named alexellis2/faas-urlping.\n\n\n\n\nDeploy your function\n\n\n\n\nNow you can use the following command to deploy your function(s):\n\n\n$ faas-cli deploy -f ./samples.yml\n\n\n\n\nManaging secrets\n\n\nYou can deploy secrets and configuration via environmental variables in-line or via external files.\n\n\n\n\nNote: external files take priority over in-line environmental variables. This allows you to specify a default and then have overrides within an external file.\n\n\n\n\nPriority:\n\n\n\n\nenvironment_file - defined in zero to many external files\n\n\n\n\n  environment_file:\n    - file1.yml\n    - file2.yml\n\n\n\n\nIf you specify a variable such as \"access_key\" in more than one \nenvironment_file\n file then the last file in the list will take priority.\n\n\nEnvironment file format:\n\n\nenvironment:\n  - access_key: key1\n  - secret_key: key2\n\n\n\n\n\n\nDefine environment in-line within the file:\n\n\n\n\nImagine you needed to define a \nhttp_proxy\n variable to operate within a corporate network:\n\n\nfunctions:\n  url-ping:\n    lang: python\n    handler: ./sample/url-ping\n    image: alexellis2/faas-urlping\n    environment:\n      http_proxy: http://proxy1.corp.com:3128\n      no_proxy: http://gateway/\n\n\n\n\nConstraints\n\n\nConstraints work with Docker Swarm and are useful for pinning functions to certain hosts.\n\n\nHere is an example of picking only Linux:\n\n\n   constraints:\n     - \"node.platform.os == linux\"\n\n\n\n\nOr only Windows:\n\n\n   constraints:\n     - \"node.platform.os == windows\"\n\n\n\n\nYAML reference\n\n\nThe possible entries for functions are documented below:\n\n\nfunctions:\n  deployed_function_name:\n    lang: node or python (optional)\n    handler: ./path/to/handler (optional)\n    image: docker-image-name\n    environment:\n      env1: value1\n      env2: \"value2\"\n   constraints:\n     - \"com.hdd == ssd\"\n\n\n\n\nUse environmental variables for setting tokens and configuration.\n\n\nAccessing the function with \ncurl\n\n\nYou can initiate a HTTP POST via \ncurl\n:\n\n\n\n\nwith the \n-d\n flag i.e. \n-d \"my data here\"\n\n\nor with \n--data-binary @filename.txt\n to send a whole file including newlines\n\n\nif you want to pass input from STDIN then use \n--data-binary @-\n\n\n\n\n$ curl -d '{\"hello\": \"world\"}' http://localhost:8080/function/nodejs-echo\n{ nodeVersion: 'v6.9.1', input: '{\"hello\": \"world\"}' }\n\n$ curl --data-binary @README.md http://localhost:8080/function/nodejs-echo\n\n$ uname -a | curl http://localhost:8080/function/nodejs-echo--data-binary @-\n\n\n\n\n\n\nFor further instructions on the manual CLI flags (without using a YAML file) read \nmanual_cli.md\n\n\n\n\nFaaS-CLI Developers / Contributors\n\n\nSee \ncontributing guide\n.\n\n\nLicense\n\n\nThis project is part of the OpenFaaS project licensed under the MIT License.",
            "title": "Cli"
        },
        {
            "location": "/faas-cli/README/#faas-cli",
            "text": "This is a CLI for use with  OpenFaaS  - a serverless functions framework for Docker & Kubernetes.   Before using this tool please setup OpenFaaS by following instructions over on the main repo.   The CLI can be used to build and deploy functions to  OpenFaaS . You can build OpenFaaS functions from a set of supported language templates (such as Node.js, Python, CSharp and Ruby). That means you just write a handler file such as (handler.py/handler.js) and the CLI does the rest to create a Docker image.  Demo:  ASCII cinema",
            "title": "faas-cli"
        },
        {
            "location": "/faas-cli/README/#tldr",
            "text": "Blog: Coffee with the FaaS-CLI",
            "title": "TL;DR"
        },
        {
            "location": "/faas-cli/README/#intall-the-cli",
            "text": "The easiest way to install the faas-cli is through a curl script or  brew :  $ curl -sSL https://cli.openfaas.com | sudo sh  or  $ brew install faas-cli   The contributing guide has instructions for building from source",
            "title": "Intall the CLI"
        },
        {
            "location": "/faas-cli/README/#run-the-cli",
            "text": "The main commands supported by the CLI are:   faas-cli new  - creates a new function via a template in the current directory  faas-cli build  - builds Docker images from the supported language types  faas-cli push  - pushes Docker images into a registry  faas-cli deploy  - deploys the functions into a local or remote OpenFaaS gateway  faas-cli remove  - removes the functions from a local or remote OpenFaaS gateway  faas-cli invoke  - invokes the functions and reads from STDIN for the body of the request   Help for all of the commands supported by the CLI can be found by running:   faas-cli help  or  faas-cli [command] --help   You can chose between using a  programming language template  where you only need to provide a handler file, or a Docker that you can build yourself.  Templates  Command:  faas-cli new FUNCTION_NAME --lang python/node/ruby/Dockerfile/etc  In your YAML you can also specify  lang: node/python/csharp/ruby   Supports common languages  Quick and easy - just write one file   Specify depenencies on Gemfile / requirements.txt or package.json etc    Customise the provided templates    Perhaps you need to have  gcc  or another dependency  in your Python template? That's not a problem.  You can customise the Dockerfile or code for any of the templates. Just create a new directory and copy in the templates folder from this repository. The templates in your current working directory are always used for builds.  See also:  faas-cli new --help  Docker image  Specify  lang: Dockerfile  if you want the faas-cli to execute a build or  skip_build: true  for pre-supplied images.   Ultimate versatility and control  Package anything  If you are using a stack file add the  skip_build: true  attribute  Use one of the  samples as a basis",
            "title": "Run the CLI"
        },
        {
            "location": "/faas-cli/README/#use-a-yaml-stack-file",
            "text": "A YAML stack file groups functions together and also saves on typing.  You can define individual functions or a set of of them within a YAML file. This makes the CLI easier to use and means you can use this file to deploy to your OpenFaaS instance.  Here is an example file using the  samples.yml  file included in the repository.  provider:\n  name: faas\n  gateway: http://localhost:8080\n\nfunctions:\n  url-ping:\n    lang: python\n    handler: ./sample/url-ping\n    image: alexellis2/faas-urlping  This url-ping function is defined in the sample/url-ping folder makes use of Python. All we had to do was to write a  handler.py  file and then to list off any Python modules in  requirements.txt .   Build the files in the .yml file:   $ faas-cli build -f ./samples.yml   -f  specifies the file or URL to download your YAML file from. The long version of the  -f  flag is:  --yaml .   You can also download over HTTP/s:  $ faas-cli build -f https://raw.githubusercontent.com/openfaas/faas-cli/master/samples.yml  Docker along with a Python template will be used to build an image named alexellis2/faas-urlping.   Deploy your function   Now you can use the following command to deploy your function(s):  $ faas-cli deploy -f ./samples.yml",
            "title": "Use a YAML stack file"
        },
        {
            "location": "/faas-cli/README/#managing-secrets",
            "text": "You can deploy secrets and configuration via environmental variables in-line or via external files.   Note: external files take priority over in-line environmental variables. This allows you to specify a default and then have overrides within an external file.   Priority:   environment_file - defined in zero to many external files     environment_file:\n    - file1.yml\n    - file2.yml  If you specify a variable such as \"access_key\" in more than one  environment_file  file then the last file in the list will take priority.  Environment file format:  environment:\n  - access_key: key1\n  - secret_key: key2   Define environment in-line within the file:   Imagine you needed to define a  http_proxy  variable to operate within a corporate network:  functions:\n  url-ping:\n    lang: python\n    handler: ./sample/url-ping\n    image: alexellis2/faas-urlping\n    environment:\n      http_proxy: http://proxy1.corp.com:3128\n      no_proxy: http://gateway/",
            "title": "Managing secrets"
        },
        {
            "location": "/faas-cli/README/#constraints",
            "text": "Constraints work with Docker Swarm and are useful for pinning functions to certain hosts.  Here is an example of picking only Linux:     constraints:\n     - \"node.platform.os == linux\"  Or only Windows:     constraints:\n     - \"node.platform.os == windows\"",
            "title": "Constraints"
        },
        {
            "location": "/faas-cli/README/#yaml-reference",
            "text": "The possible entries for functions are documented below:  functions:\n  deployed_function_name:\n    lang: node or python (optional)\n    handler: ./path/to/handler (optional)\n    image: docker-image-name\n    environment:\n      env1: value1\n      env2: \"value2\"\n   constraints:\n     - \"com.hdd == ssd\"  Use environmental variables for setting tokens and configuration.  Accessing the function with  curl  You can initiate a HTTP POST via  curl :   with the  -d  flag i.e.  -d \"my data here\"  or with  --data-binary @filename.txt  to send a whole file including newlines  if you want to pass input from STDIN then use  --data-binary @-   $ curl -d '{\"hello\": \"world\"}' http://localhost:8080/function/nodejs-echo\n{ nodeVersion: 'v6.9.1', input: '{\"hello\": \"world\"}' }\n\n$ curl --data-binary @README.md http://localhost:8080/function/nodejs-echo\n\n$ uname -a | curl http://localhost:8080/function/nodejs-echo--data-binary @-   For further instructions on the manual CLI flags (without using a YAML file) read  manual_cli.md",
            "title": "YAML reference"
        },
        {
            "location": "/faas-cli/README/#faas-cli-developers-contributors",
            "text": "See  contributing guide .",
            "title": "FaaS-CLI Developers / Contributors"
        },
        {
            "location": "/faas-cli/README/#license",
            "text": "This project is part of the OpenFaaS project licensed under the MIT License.",
            "title": "License"
        },
        {
            "location": "/faas-cli/MANUAL_CLI/",
            "text": "Manual CLI options\n\n\nIn addition to YAML file support, you can use the CLI to build and deploy individual functions as follows:\n\n\nWorked example with Node.js\n\n\nSo if you want to write in another language, just prepare a Dockerfile and build an image manually, like in the \nFaaS samples\n.\n\n\nBuild a FaaS function in NodeJS from a template:\n\n\nThis will generate a Docker image for a Node.js function using the code in \n/samples/info\n.\n\n\n\n\nThe \nfaas-cli build\n command can accept a \n--lang\n option of \npython\n or \nnode\n and is \nnode\n by default.\n\n\n\n\n   $ faas-cli build \\\n      --image=alexellis2/node_info \\\n      --name=node_info \\\n      --handler=./sample/node_info\n\nBuilding: alexellis2/node_info with Docker. Please wait..\n...\nImage: alexellis2/node_info built.\n\n\n\n\nYou can customise the code by editing the handler.js file and changing the \n--handler\n parameter. You can also edit the packages.json file, which will be used during the build to make sure all your dependencies are available at runtime.\n\n\nFor example:\n\n\n\"use strict\"\n\nmodule.exports = (context, callback) => {\n    console.log(\"echo - \" + context);\n\n    callback(undefined, {status: \"done\"});\n}\n\n\n\n\nThe CLI will then build a Docker image containing the FaaS watchdog and a bootstrap file to invoke your NodeJS function.\n\n\nDeploy the Docker image as a FaaS function:\n\n\nNow we can deploy the image as a named function called \nnode_info\n.\n\n\n$ faas-cli deploy \\\n   --image=alexellis2/node_info \\\n   --name=node_info\n\n200 OK\n\nURL: http://localhost:8080/function/node_info\n\n\n\n\n\n\nThis tool can be used to deploy any Docker image as a FaaS function, as long as it includes the watchdog binary as the \nCMD\n or \nENTRYPOINT\n of the image.\n\n\n\n\nDeploy remotely\n\n\nYou can deploy to a remote FaaS instance as along as you push the image to the Docker Hub, or another accessible Docker registry. Specify your remote gateway with the following flag: \n--gateway=http://remote-site.com:8080",
            "title": "Manual"
        },
        {
            "location": "/faas-cli/MANUAL_CLI/#manual-cli-options",
            "text": "In addition to YAML file support, you can use the CLI to build and deploy individual functions as follows:",
            "title": "Manual CLI options"
        },
        {
            "location": "/faas-cli/MANUAL_CLI/#worked-example-with-nodejs",
            "text": "So if you want to write in another language, just prepare a Dockerfile and build an image manually, like in the  FaaS samples .  Build a FaaS function in NodeJS from a template:  This will generate a Docker image for a Node.js function using the code in  /samples/info .   The  faas-cli build  command can accept a  --lang  option of  python  or  node  and is  node  by default.      $ faas-cli build \\\n      --image=alexellis2/node_info \\\n      --name=node_info \\\n      --handler=./sample/node_info\n\nBuilding: alexellis2/node_info with Docker. Please wait..\n...\nImage: alexellis2/node_info built.  You can customise the code by editing the handler.js file and changing the  --handler  parameter. You can also edit the packages.json file, which will be used during the build to make sure all your dependencies are available at runtime.  For example:  \"use strict\"\n\nmodule.exports = (context, callback) => {\n    console.log(\"echo - \" + context);\n\n    callback(undefined, {status: \"done\"});\n}  The CLI will then build a Docker image containing the FaaS watchdog and a bootstrap file to invoke your NodeJS function.  Deploy the Docker image as a FaaS function:  Now we can deploy the image as a named function called  node_info .  $ faas-cli deploy \\\n   --image=alexellis2/node_info \\\n   --name=node_info\n\n200 OK\n\nURL: http://localhost:8080/function/node_info   This tool can be used to deploy any Docker image as a FaaS function, as long as it includes the watchdog binary as the  CMD  or  ENTRYPOINT  of the image.   Deploy remotely  You can deploy to a remote FaaS instance as along as you push the image to the Docker Hub, or another accessible Docker registry. Specify your remote gateway with the following flag:  --gateway=http://remote-site.com:8080",
            "title": "Worked example with Node.js"
        },
        {
            "location": "/faas-cli/Notes/",
            "text": "Command\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuild verb\n\n\n\n\n\n\n\n\nfaas-cli\n\n\nprints available verbs and global flags (think of docker/kubectl etc)\n\n\n\n\n\n\nfaas-cli --help\n\n\nas above\n\n\n\n\n\n\nfaas-cli build\n\n\nhelp for build verb\n\n\n\n\n\n\nfaas-cli build --help\n\n\nas above\n\n\n\n\n\n\nfaas-cli build .\n\n\nBuild using a local \nFaasfile\n (ie default name for the YAML) with context set to \n.\n (handlers are relative to this)\n\n\n\n\n\n\nfaas-cli build -f /path/to/yaml .\n\n\nAs above but explictly pointing to YAML path or URL\n\n\n\n\n\n\nfaas-cli build . url-ing\n\n\nContext set to \n.\n but only building a specific function (thinking of the \nsamples.yml\n with multiple fns). I'm a bit torn by this, probably better to avoid being clever.\n\n\n\n\n\n\ndeploy verb\n\n\n\n\n\n\n\n\nfaas-cli deploy\n\n\nhelp for build verb\n\n\n\n\n\n\nfaas-cli deploy --help\n\n\nas above\n\n\n\n\n\n\nfaas-cli deploy .\n\n\nDeploys using the \nFaasfile\n in the PWD\n\n\n\n\n\n\nfaas-cli deploy -f /path/to/yaml\n\n\nDeploys using the YAML at the specified path or URL\n\n\n\n\n\n\nfaas-cli deploy -f /path/to/yaml ruby-echo\n\n\nas above but only deploys the specified function\n\n\n\n\n\n\nfaas-cli deploy -f /path/to/yaml ruby-echo --force\n\n\noverwrites an existing function if it exists (default would be to warn that function already exists)\n\n\n\n\n\n\n\n\nSpitballing some new stuff..\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage verb\n\n\n\n\n\n\n\n\nfaas-cli image\n\n\nprints available subverbs below and global flags\n\n\n\n\n\n\nlist sub-verb\n\n\n\n\n\n\n\n\nfaas-cli image list\n\n\nlist all FaaS built images, would be based on build adding a magic label\n\n\n\n\n\n\nrm sub-verb\n\n\n\n\n\n\n\n\nfaas-cli image rm alexellis/faas-url-ping\n\n\ndeletes the \nalexellis/faas-url-ping\n image only if it was created by FaaS, ie has a magic label\n\n\n\n\n\n\nfunction verb\n\n\n\n\n\n\n\n\nfaas-cli function\n\n\nprints available subverbs below and global flags\n\n\n\n\n\n\nlist sub-verb\n\n\n\n\n\n\n\n\nfaas-cli function list\n\n\nlist all running FaaS function containers, would be based on deploy adding a magic label\n\n\n\n\n\n\nrm sub-verb\n\n\n\n\n\n\n\n\nfaas-cli function rm shrink-image\n\n\ndeletes the \nfunc_shrink-image.xxxx\n containers\n\n\n\n\n\n\ndescribe sub-verb\n\n\n\n\n\n\n\n\nfaas-cli function describe shrink-image\n\n\ndescribes the \nfunc_shrink-image.xxxx\n containers, could allow the user to add a description to the functions yaml definition that gets added as a label to either the image of the container\n\n\n\n\n\n\nprovider verb\n\n\n\n\n\n\n\n\nfaas-cli provider list\n\n\nlists known FaaS providers, say \nprod\n/\nstaging\n/\nlocal\n etc\n\n\n\n\n\n\nfaas-cli provider add prod https://prod:8080 --network func_functions\n\n\nAdds a new provider called \nprod\n, likely cache this locally, perhaps in \n~/.faas-cli/\n\n\n\n\n\n\nfaas-cli provider rm prod\n\n\nRemove above from the cache\n\n\n\n\n\n\nfaas-cli provider login prod\n\n\nPrompt the user to authenticate with the provider, cache locally (Apache Brooklyns cli does something similar)\n\n\n\n\n\n\nThis could then enable stuff like..\n\n\n\n\n\n\n\n\nfaas-cli deploy -f /path/to/yaml prod\n\n\noverride the provider in the YAML and deploy to \nprod",
            "title": "Notes"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/",
            "text": "Contributing\n\n\nLicense\n\n\nThis project is licensed under the MIT License.\n\n\nGuidelines apply from main OpenFaaS repo\n\n\nSee guide for \nFaaS\n here.\n\n\nUnit testing with Golang\n\n\nPlease follow style guide on \nthis blog post\n from \nThe Go Programming Language\n\n\nHacking on the faas-cli\n\n\nInstallation / pre-requirements\n\n\n\n\nDocker\n\n\n\n\nInstall Docker because it is used to build Docker images if you create new functions.\n\n\n\n\nOpenFaaS - deployed and live\n\n\n\n\nThis CLI can build and deploy templated functions, so it's best if you have FaaS started up on your laptop. Head over to http://github.com/openfaas/faas/ and get up and running with a sample stack in 60 seconds.\n\n\n\n\nGolang\n\n\n\n\n\n\nHere's how to install Go in 60 seconds.\n\n\n\n\n\n\nGrab Go 1.7.x or 1.8.3 from https://golang.org/dl/\n\n\n\n\nThen after installing run this command or place it in your \n$HOME/.bash_profile\n\n\nexport GOPATH=$HOME/go\nexport PATH=$PATH:$GOPATH/bin\n\n\n\n\n\n\nNow clone / build \nfaas-cli\n:\n\n\n\n\nMigrate all imports/references to OpenFaaS org\n$ mkdir -p $GOPATH/src/github.com/openfaas/\n$ cd $GOPATH/src/github.com/openfaas/\n$ git clone https://github.com/openfaas/faas-cli\n$ cd faas-cli\n$ go build\n\n\n\n\n\n\nBuild multi-arch binaries\n\n\n\n\nTo build the release binaries type in:\n\n\n./build_redist.sh\n\n\n\n\nThis creates the faas-cli for Mac, Windows, Linux x64, Linux ARMHF and Linux ARM64.\n\n\n\n\nGet the vendoring tool called \nvndr\n\n\n\n\n$ go install github.com/LK4D4/vndr\n\n\n\n\nUse the tool if you add new dependencies or want to update the existing ones.\n\n\n\n\nSee also: \nvndr docs\n\n\n\n\nHow to update the \nbrew\n formula\n\n\nThe \nbrew\n formula for the faas-cli is part of the official \nhomebrew-core\n repo on Github. It needs to be updated for each subsequent release.\n\n\nSimple version bumps\n\n\nIf the only change required is a version bump, ie no new tests, or changes to existing tested functionality or build steps, the \nbrew bump-formula-pr\n command can be used to do everything (i.e. forking, committing, pushing) required to bump the version.\n\n\nFor example (supplying both the new version tag and its associated Git sha-256).\n\n\nbrew bump-formula-pr --strict faas-cli --tag=<version> --revision=<sha-256>\n\n\n\n\nChanges requiring new/update tests/build steps\n\n\nIf a new release alters behaviour tested in the Brew Formula, adds new testable behaviors or alters the build steps then you will need to manually raise a PR with an updated Formula, the guidelines for updating brew describe the process in more detail:\n\n\nhttps://github.com/Homebrew/homebrew-core/blob/master/CONTRIBUTING.md\n\n\nAfter \nbrew edit\n run the build and test the results:\n\n\n$ brew uninstall --force faas-cli ; \\\n  brew install --build-from-source faas-cli ; \\\n  brew test faas-cli ; \\\n  brew audit --strict faas-cli\n\n\n\n\nUpdate the utility-script\n\n\nPlease raise a PR for the get.sh file held in this repository. It's used when people install via \ncurl\n and \ncli.openfaas.com\n. The updated file then has to be redeployed to the hosting server.\n\n\nDeveloper DCO (re-iteration from referenced CONTRIBUTING guide)\n\n\nSign your work\n\n\n\n\nNote: all of the commits in your PR/Patch must be signed-off.\n\n\n\n\nThe sign-off is a simple line at the end of the explanation for a patch. Your\nsignature certifies that you wrote the patch or otherwise have the right to pass\nit on as an open-source patch. The rules are pretty simple: if you can certify\nthe below (from \ndevelopercertificate.org\n):\n\n\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n\n\n\n\nThen you just add a line to every git commit message:\n\n\nSigned-off-by: Joe Smith <joe.smith@email.com>\n\n\n\nUse your real name (sorry, no pseudonyms or anonymous contributions.)\n\n\nIf you set your \nuser.name\n and \nuser.email\n git configs, you can sign your\ncommit automatically with \ngit commit -s\n.\n\n\n\n\nPlease sign your commits with \ngit commit -s\n so that commits are traceable.\n\n\n\n\nMisc\n\n\nBash Auto-completion [experimental]\n\n\nAn experimental initial Bash auto-completion script for \nfaas-cli\n is available at \ncontrib/bash/faas-cli\n.\n\n\nPlease raise issues with feedback and suggestions on improvements to the auto-completion support.\n\n\nThis may be enabled it as follows.\n\n\nEnabling Bash auto-completion on OSX\n\n\nBrew install the \nbash_completions\n package.\n\n\n$ brew install bash-completion\n\n\n\n\nAdd the following line to your \n~/.bash_profile\n if not already present.\n\n\n[ -f /usr/local/etc/bash_completion ] && . /usr/local/etc/bash_completion\n\n\n\n\nCopy the provided \nfaas-cli\n bash completion script from this repo.\n\n\ncp contrib/bash/faas-cli /usr/local/etc/bash_completion.d/\n\n\n\n\nEnabling Bash auto-completion on Linux\n\n\nRefer to your distributions instructions on installing and enabling \nbash-completion\n, then copy the \nfaas-cli\n completion script from \ncontrib/bash/\n into the appropriate completion directory.",
            "title": "Contributing"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#contributing",
            "text": "",
            "title": "Contributing"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#license",
            "text": "This project is licensed under the MIT License.",
            "title": "License"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#guidelines-apply-from-main-openfaas-repo",
            "text": "See guide for  FaaS  here.",
            "title": "Guidelines apply from main OpenFaaS repo"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#unit-testing-with-golang",
            "text": "Please follow style guide on  this blog post  from  The Go Programming Language",
            "title": "Unit testing with Golang"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#hacking-on-the-faas-cli",
            "text": "",
            "title": "Hacking on the faas-cli"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#installation-pre-requirements",
            "text": "Docker   Install Docker because it is used to build Docker images if you create new functions.   OpenFaaS - deployed and live   This CLI can build and deploy templated functions, so it's best if you have FaaS started up on your laptop. Head over to http://github.com/openfaas/faas/ and get up and running with a sample stack in 60 seconds.   Golang    Here's how to install Go in 60 seconds.    Grab Go 1.7.x or 1.8.3 from https://golang.org/dl/   Then after installing run this command or place it in your  $HOME/.bash_profile  export GOPATH=$HOME/go\nexport PATH=$PATH:$GOPATH/bin   Now clone / build  faas-cli :   Migrate all imports/references to OpenFaaS org\n$ mkdir -p $GOPATH/src/github.com/openfaas/\n$ cd $GOPATH/src/github.com/openfaas/\n$ git clone https://github.com/openfaas/faas-cli\n$ cd faas-cli\n$ go build   Build multi-arch binaries   To build the release binaries type in:  ./build_redist.sh  This creates the faas-cli for Mac, Windows, Linux x64, Linux ARMHF and Linux ARM64.   Get the vendoring tool called  vndr   $ go install github.com/LK4D4/vndr  Use the tool if you add new dependencies or want to update the existing ones.   See also:  vndr docs",
            "title": "Installation / pre-requirements"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#how-to-update-the-brew-formula",
            "text": "The  brew  formula for the faas-cli is part of the official  homebrew-core  repo on Github. It needs to be updated for each subsequent release.",
            "title": "How to update the brew formula"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#simple-version-bumps",
            "text": "If the only change required is a version bump, ie no new tests, or changes to existing tested functionality or build steps, the  brew bump-formula-pr  command can be used to do everything (i.e. forking, committing, pushing) required to bump the version.  For example (supplying both the new version tag and its associated Git sha-256).  brew bump-formula-pr --strict faas-cli --tag=<version> --revision=<sha-256>",
            "title": "Simple version bumps"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#changes-requiring-newupdate-testsbuild-steps",
            "text": "If a new release alters behaviour tested in the Brew Formula, adds new testable behaviors or alters the build steps then you will need to manually raise a PR with an updated Formula, the guidelines for updating brew describe the process in more detail:  https://github.com/Homebrew/homebrew-core/blob/master/CONTRIBUTING.md  After  brew edit  run the build and test the results:  $ brew uninstall --force faas-cli ; \\\n  brew install --build-from-source faas-cli ; \\\n  brew test faas-cli ; \\\n  brew audit --strict faas-cli",
            "title": "Changes requiring new/update tests/build steps"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#update-the-utility-script",
            "text": "Please raise a PR for the get.sh file held in this repository. It's used when people install via  curl  and  cli.openfaas.com . The updated file then has to be redeployed to the hosting server.",
            "title": "Update the utility-script"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#developer-dco-re-iteration-from-referenced-contributing-guide",
            "text": "",
            "title": "Developer DCO (re-iteration from referenced CONTRIBUTING guide)"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#sign-your-work",
            "text": "Note: all of the commits in your PR/Patch must be signed-off.   The sign-off is a simple line at the end of the explanation for a patch. Your\nsignature certifies that you wrote the patch or otherwise have the right to pass\nit on as an open-source patch. The rules are pretty simple: if you can certify\nthe below (from  developercertificate.org ):  Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.  Then you just add a line to every git commit message:  Signed-off-by: Joe Smith <joe.smith@email.com>  Use your real name (sorry, no pseudonyms or anonymous contributions.)  If you set your  user.name  and  user.email  git configs, you can sign your\ncommit automatically with  git commit -s .   Please sign your commits with  git commit -s  so that commits are traceable.",
            "title": "Sign your work"
        },
        {
            "location": "/faas-cli/CONTRIBUTING/#misc",
            "text": "Bash Auto-completion [experimental]  An experimental initial Bash auto-completion script for  faas-cli  is available at  contrib/bash/faas-cli .  Please raise issues with feedback and suggestions on improvements to the auto-completion support.  This may be enabled it as follows.  Enabling Bash auto-completion on OSX  Brew install the  bash_completions  package.  $ brew install bash-completion  Add the following line to your  ~/.bash_profile  if not already present.  [ -f /usr/local/etc/bash_completion ] && . /usr/local/etc/bash_completion  Copy the provided  faas-cli  bash completion script from this repo.  cp contrib/bash/faas-cli /usr/local/etc/bash_completion.d/  Enabling Bash auto-completion on Linux  Refer to your distributions instructions on installing and enabling  bash-completion , then copy the  faas-cli  completion script from  contrib/bash/  into the appropriate completion directory.",
            "title": "Misc"
        }
    ]
}